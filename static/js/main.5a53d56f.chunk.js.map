{"version":3,"sources":["components/Canvas.jsx","components/App.jsx","index.js"],"names":["Canvas","props","draw","options","rest","canvasRef","React","useRef","useEffect","animationFrameId","context","current","getContext","frameCount","render","window","requestAnimationFrame","cancelAnimationFrame","useCanvas","ref","App","useState","gridSize","gridWidth","setGridWidth","gridHeight","setGridHeight","w","h","rooms","checkCollision","a","b","padding","x","width","y","height","roomsToPlace","i","roomWidth","Math","floor","random","roomHeight","push","forEach","r","placed","tries","valid","xPos","yPos","newRoom","find","room","ctx","two","Two","type","Types","canvas","domElement","makeLine","stroke","j","rect","makeRectangle","fill","opacity","update","style","borderStyle","onChange","event","target","value","name","step","min","max","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.5a53d56f.chunk.js","sourcesContent":["import React from 'react'\r\n\r\nfunction Canvas(props) {\r\n    const { draw, options, ...rest } = props\r\n    const canvasRef = useCanvas(draw, options)\r\n  \r\n    // Hard code 200 for now\r\n    return <canvas ref={canvasRef} {...rest}/>\r\n}\r\n\r\n// Returns a refernce to a canvas with a specific draw function, and options (such as context)\r\nfunction useCanvas(draw, options={}) {\r\n    const canvasRef = React.useRef(null)\r\n  \r\n    // useEffect() hook essentially runs right after the component (the Canvas) is mounted\r\n    // Every time we change the draw, the function of the useEffect will be called again for the new draw.\r\n    // The dependencies array will be watched by useEffect and run whenever a dependency is changed\r\n    React.useEffect(() => {\r\n    \r\n        const canvas = canvasRef.current\r\n        const context = canvas.getContext(options.context || '2d')\r\n        let frameCount = 0\r\n        let animationFrameId\r\n        \r\n        // All the steps that will be repeated in the animation. render() will be called recursively by the requestAnimationFrame method.\r\n        const render = () => {\r\n            frameCount++\r\n            draw(context, frameCount)\r\n            animationFrameId = window.requestAnimationFrame(render)\r\n        }\r\n        render()\r\n        \r\n        // Clean-up. Called right before the component unmount. That way we can ensure that our animation frame is cancelled after our canvas component unmount.\r\n        return () => {\r\n        window.cancelAnimationFrame(animationFrameId)\r\n        }\r\n    }, [draw, options])\r\n  \r\n    return canvasRef\r\n}\r\n\r\n// TODO: Look at referenced medium article\r\n// Add Resizing function\r\n// Add handling high pixel density screens (like smartphones)\r\n// Look into predraw and postdraw functions (in case we want to do something like clearing the screen, saving it, etc)\r\n\r\nexport default Canvas\r\n\r\n// for reference\r\n// https://medium.com/@pdx.lucasm/canvas-with-react-js-32e133c05258","import React from 'react'\r\nimport Canvas from './Canvas'\r\nimport Two from 'two.js';\r\n\r\nfunction App() {\r\n    const [gridSize, setGridSize] = React.useState(25);\r\n    const [gridWidth, setGridWidth] = React.useState(20);\r\n    const [gridHeight, setGridHeight] = React.useState(20);\r\n    var w = 600;\r\n    var h = 600;\r\n\r\n    // --- Code the created rooms --- // TODO: Move it into external file\r\n    const rooms = [];\r\n\r\n    function checkCollision(a, b, padding=0) {\r\n        if (a.x - padding * gridSize < b.x + b.width && \r\n            a.x + a.width + padding * gridSize > b.x && \r\n            a.y - padding * gridSize < b.y + b.height && \r\n            a.y + a.height + padding * gridSize > b.y) {\r\n                return true;\r\n            } \r\n        return false;\r\n    }\r\n\r\n    // Room creation variable\r\n    // TODO: Make these user input\r\n    let targetRoomCount = 10;\r\n    let roomMinSize = 3;\r\n    let roomMaxSize = 7;\r\n\r\n    // Creates a set of random rooms we will try to place\r\n    const roomsToPlace = [];\r\n    for(var i = 0; i < targetRoomCount; i++){\r\n        let roomWidth = (Math.floor(Math.random() * (roomMaxSize - roomMinSize)) + roomMinSize) * gridSize;\r\n        let roomHeight = (Math.floor(Math.random() * (roomMaxSize - roomMinSize)) + roomMinSize) * gridSize;\r\n        roomsToPlace.push({\r\n            width: roomWidth,\r\n            height: roomHeight\r\n        });\r\n    }\r\n\r\n    let maxTries = 10;\r\n    roomsToPlace.forEach((r) => {\r\n        let placed = false;\r\n        let tries = 0;\r\n        while(!placed && tries < maxTries) {\r\n\r\n\r\n            // Try to place a room at a random spot\r\n            let valid = true;\r\n            let xPos = Math.floor(Math.random() * gridWidth) * gridSize;\r\n            let yPos = Math.floor(Math.random() * gridHeight) * gridSize;\r\n\r\n            // See if room is in bounds\r\n            if(xPos + r.width < gridWidth*gridSize && yPos + r.height < gridHeight*gridSize) {\r\n                let newRoom = {\r\n                    x: xPos,\r\n                    y: yPos,\r\n                    width: r.width,\r\n                    height: r.height\r\n                };\r\n\r\n                let collidedRoom = rooms.find(function(room) {\r\n                    return checkCollision(newRoom, room, 1);\r\n                });\r\n\r\n                if(collidedRoom != null) {\r\n                    valid = false;\r\n                }\r\n            }\r\n            else {\r\n                valid = false;\r\n            }\r\n\r\n            if(valid){\r\n                rooms.push({\r\n                    x: xPos,\r\n                    y: yPos,\r\n                    width: r.width,\r\n                    height: r.height\r\n                });\r\n                placed = true;\r\n            }\r\n            else {\r\n                tries++;\r\n            }\r\n        }\r\n    });\r\n\r\n    // --- End of creating rooms --- //\r\n\r\n\r\n    function changeGridHeight(event) {\r\n        const { name, value } = event.target;\r\n\r\n        setGridHeight(value);\r\n    }\r\n\r\n    function changeGridWidth(event) {\r\n        const { name, value } = event.target;\r\n\r\n        setGridWidth(value);\r\n    }\r\n\r\n    function changeGridSize(event) {\r\n        const { name, value } = event.target;\r\n\r\n        setGridSize(value);\r\n    }\r\n\r\n    // Define a draw function\r\n    // https://two.js.org/#basic-usage\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    const draw = (ctx, frameCount) => {\r\n        w = gridSize * gridWidth;\r\n        h = gridSize * gridHeight;\r\n\r\n        var two = new Two({\r\n            type: Two.Types.canvas,\r\n            width: w,\r\n            height: h,\r\n            domElement: ctx.canvas\r\n        });\r\n\r\n        for(var i = 0; i < w; i+=gridSize) {\r\n            var line = two.makeLine(i, 0, i, h);\r\n            line.stroke = 'DarkGray';\r\n        }\r\n\r\n        for(var j = 0; j < h; j+=gridSize) {\r\n            var line = two.makeLine(0, j, w, j);\r\n            line.stroke = 'DarkGray';\r\n        }\r\n\r\n        rooms.forEach((r) => {\r\n            // Takes center of rect as it's x/y\r\n            var rect = two.makeRectangle(r.x + (r.width / 2), r.y + (r.height/2), r.width, r.height);\r\n            rect.fill = 'orangered';\r\n            rect.opacity = 0.5;\r\n        });\r\n\r\n        // Draw all rooms\r\n\r\n          \r\n        two.update();\r\n    }\r\n\r\n  return <div>\r\n    <Canvas \r\n        draw={draw} \r\n        options={{\r\n            context: '2d'\r\n            }}\r\n        style={{\r\n            borderStyle: 'solid'\r\n        }}\r\n        width={w}\r\n        height={h}\r\n        />\r\n        {/*TODO: Make this a submittable form\r\n            - Maybe make a static canvas size, and just draw the map in it\r\n                to prevent resizing when using range*/}\r\n    <form>\r\n        <label>Height: {gridHeight}</label>\r\n        <input type='range' onChange={changeGridHeight} step='1' min='1' max='50' value={gridHeight}></input>\r\n        <label>Width: {gridWidth}</label>\r\n        <input type='range' onChange={changeGridWidth} step='1' min='1' max='50' value={gridWidth}></input>\r\n    </form>\r\n  </div>;\r\n}\r\n\r\nexport default App","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\n\nReactDOM.render(<App />, \n  document.getElementById('root')\n);\n\n// https://dev.to/yuribenjamin/how-to-deploy-react-app-in-github-pages-2a1f\n// For changes, commit and push to remote master, then run \"npm run deploy\" again\n"],"sourceRoot":""}