{"version":3,"sources":["components/RoomData.jsx","components/Canvas.jsx","components/Header.jsx","components/Form.jsx","utils/adj-matrix.graph.js","utils/map.js","components/App.jsx","index.js"],"names":["RoomData","props","data","Canvas","draw","options","rest","canvasRef","React","useRef","useEffect","context","current","getContext","useCanvas","ref","Header","Form","useState","gridWidth","setGridWidth","gridHeight","setGridHeight","targetRoomCount","setTargetRoomCount","roomSize","setRoomSize","connectivity","setConnectivity","type","className","min","max","step","name","onChange","event","target","value","onClick","changeHeight","changeWidth","minSize","maxSize","console","log","onGenerate","Graph","size","this","matrix","mst","i","push","j","vertex1","vertex2","weight","row","keys","mstSet","Number","MAX_VALUE","minIndex","parents","u","minKey","v","forEach","dst","src","idx1","cost","idx2","addEdge","Math","random","Map","rooms","paths","focusedRoom","a","b","padding","x","width","y","height","sqrt","generatedRooms","roomsToPlace","diff","roomWidth","floor","roomHeight","roomNum","r","placed","tries","valid","xPos","yPos","newRoom","find","room","checkCollision","id","focused","generatedPaths","maxCost","MIN_VALUE","r1","ar","r2","distance","getMidPoint","primMST","removeEdge","unsetFocusedRoom","App","gridSize","map","setMap","selectedRoom","setSelectedRoom","w","h","numRooms","mapWidth","mapHeight","m","generateRooms","generatePaths","ctx","two","Two","Types","canvas","domElement","makeLine","stroke","txt","makeText","opacity","rect","makeRectangle","fill","room1","room2","line","lineWidth","update","style","borderStyle","mouseX","nativeEvent","layerX","mouseY","layerY","roomClicked","findIndex","setFocusedRoom","getRoomParams","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.66f68f32.chunk.js","sourcesContent":["import React from 'react'\r\n\r\nfunction RoomData(props) {\r\n    return <p>{props.data}</p>;\r\n}\r\n\r\nexport default RoomData;","import React from 'react'\r\n\r\nfunction Canvas(props) {\r\n    const { draw, options, ...rest } = props\r\n    const canvasRef = useCanvas(draw, options)\r\n  \r\n    // Hard code 200 for now\r\n    return <canvas ref={canvasRef} {...rest}/>\r\n}\r\n\r\n// Returns a refernce to a canvas with a specific draw function, and options (such as context)\r\nfunction useCanvas(draw, options={}) {\r\n    const canvasRef = React.useRef(null)\r\n  \r\n    // useEffect() hook essentially runs right after the component (the Canvas) is mounted\r\n    // Every time we change the draw, the function of the useEffect will be called again for the new draw.\r\n    // The dependencies array will be watched by useEffect and run whenever a dependency is changed\r\n    React.useEffect(() => {\r\n    \r\n        const canvas = canvasRef.current\r\n        const context = canvas.getContext(options.context || '2d')\r\n        draw(context);\r\n\r\n        // Removed animation as it wasn't needed and caused memory issues\r\n        // let frameCount = 0\r\n        // let animationFrameId\r\n        // // All the steps that will be repeated in the animation. render() will be called recursively by the requestAnimationFrame method.\r\n        // const render = () => {\r\n        //     frameCount++\r\n        //     draw(context, frameCount)\r\n        //     animationFrameId = window.requestAnimationFrame(render)\r\n        // }\r\n        // render()\r\n        \r\n        // // Clean-up. Called right before the component unmount. That way we can ensure that our animation frame is cancelled after our canvas component unmount.\r\n        // return () => {\r\n        // window.cancelAnimationFrame(animationFrameId)\r\n        // }\r\n    }, [draw, options])\r\n  \r\n    return canvasRef\r\n}\r\n\r\n// TODO: Look at referenced medium article\r\n// Add Resizing function\r\n// Add handling high pixel density screens (like smartphones)\r\n// Look into predraw and postdraw functions (in case we want to do something like clearing the screen, saving it, etc)\r\n\r\nexport default Canvas\r\n\r\n// for reference\r\n// https://medium.com/@pdx.lucasm/canvas-with-react-js-32e133c05258","import React from 'react'\r\n\r\nfunction Header(props) {\r\n    return <header>\r\n        <h1>Dungeon Generator</h1>\r\n    </header>;\r\n}\r\n\r\nexport default Header;","import React from 'react'\r\n\r\nfunction Form(props){\r\n\r\n    const [gridSize, setGridSize] = React.useState(25);\r\n    const [gridWidth, setGridWidth] = React.useState(20);\r\n    const [gridHeight, setGridHeight] = React.useState(20);\r\n    const [targetRoomCount, setTargetRoomCount] = React.useState(10);\r\n    const [roomSize, setRoomSize] = React.useState('reg');\r\n    const [connectivity, setConnectivity] = React.useState('sparse');\r\n\r\n    // -- Setting up the room parameters -- //\r\n    function changeTargetRoomCount(event) {\r\n        const { name, value } = event.target;\r\n        setTargetRoomCount(value);\r\n    }\r\n\r\n    function changeRoomSize(event) {\r\n        const { name, value } = event.target;\r\n        setRoomSize(value);\r\n    }\r\n\r\n    function changeConnectivity(event) {\r\n        const { name, value } = event.target;\r\n        setConnectivity(value);\r\n    }\r\n\r\n    function changeGridHeight(event) {\r\n        const { name, value } = event.target;\r\n\r\n        // TODO: Re-enable after getting form submission\r\n        setGridHeight(value);\r\n    }\r\n\r\n    function changeGridWidth(event) {\r\n        const { name, value } = event.target;\r\n\r\n        // TODO: Re-enable after getting form submission\r\n        setGridWidth(value);\r\n    }\r\n\r\n    // function changeGridSize(event) {\r\n    //     const { name, value } = event.target;\r\n\r\n    //     // TODO: Re-enable after getting form submission\r\n    //     // setGridSize(value);\r\n    // }\r\n\r\n    function resize(event) {\r\n        props.changeHeight(gridHeight);\r\n        props.changeWidth(gridWidth);\r\n    }\r\n\r\n    function genDungeon() {\r\n        let minSize;\r\n        let maxSize;\r\n        if(roomSize === 'small') {\r\n            minSize = 1;\r\n            maxSize = 5;\r\n        }\r\n        else if(roomSize === 'reg'){\r\n            minSize = 3;\r\n            maxSize = 7;\r\n        }\r\n        else if(roomSize === 'large'){\r\n            minSize = 5;\r\n            maxSize = 10;\r\n        }\r\n        else {\r\n            console.log('error: ' + roomSize);\r\n        }\r\n\r\n        props.onGenerate(targetRoomCount, minSize, maxSize, gridWidth, gridHeight, connectivity);\r\n    }\r\n\r\n    // TODO: Set reasonable max value for the ranges\r\n    return  <form>\r\n        <label>Height: {gridHeight}</label>\r\n        <input type='range' className=\"form-range\" min='1' max='50' step='1' name='height' onChange={changeGridHeight} value={gridHeight}></input>\r\n        <label>Width: {gridWidth}</label>\r\n        <input type='range' className=\"form-range\" min='1' max='50' step='1' name='width' onChange={changeGridWidth} value={gridWidth}></input>\r\n        \r\n\r\n        <label>Max Rooms: {targetRoomCount}</label>\r\n        <input type='range' className=\"form-range\" min='1' max='100' step='1' name='roomCount' onChange={changeTargetRoomCount} value={targetRoomCount}></input>\r\n        <label>Room Sizes: </label>\r\n        <select className=\"form-select form-select-sm\" value={roomSize} onChange={changeRoomSize}>\r\n            <option value='small'>Small (1x1 - 5x5)</option>\r\n            <option value='reg'>Regular (3x3 - 7x7)</option>\r\n            <option value='large'>Large (5x5 - 10x10)</option>\r\n        </select>\r\n        <label>Connectivity: </label>\r\n        <select className=\"form-select form-select-sm\" value={connectivity} onChange={changeConnectivity}>\r\n            {/* Linear = 0.00, Sparse = 0.25, normal = 0.50, dense = 0.75, complete = 1.00 */}\r\n            <option value='linear'>Linear</option>\r\n            <option value='sparse'>Sparse</option>\r\n            <option value='normal'>Normal</option>\r\n            <option value='dense'>Dense</option>\r\n            <option value='complete'>Complete</option>\r\n        </select>\r\n        <button type='button' className='btn btn-secondary' onClick={resize}>Resize</button>\r\n        <button type='button' className='btn btn-primary' onClick={genDungeon}>Generate</button>\r\n    </form>;\r\n}\r\n\r\nexport default Form;","class Graph {\r\n\r\n    // Define a graph with a adj matrix with weights = 0\r\n    constructor(size = 1) {\r\n        this.size = size;\r\n        this.matrix = [];\r\n        this.mst = [];\r\n        for (let i = 0; i < size; i++) {\r\n            this.matrix.push([]);\r\n            this.mst.push([]);\r\n            for (let j = 0; j < size; j++) {\r\n                this.matrix[i][j] = 0;\r\n                this.mst[i][j] = 0;\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    // Add an edge, checking first to see if vertices are valid\r\n    addEdge(vertex1, vertex2, weight = 1) {\r\n        if (vertex1 > this.size - 1 || vertex2 > this.size - 1) {\r\n            console.log('invalid vertex');\r\n        } else if (vertex1 === vertex2) {\r\n            this.matrix[vertex1][vertex2] = 0;\r\n            this.matrix[vertex2][vertex1] = 0;\r\n        } else {\r\n            this.matrix[vertex1][vertex2] = weight;\r\n            this.matrix[vertex2][vertex1] = weight;\r\n        }\r\n    }\r\n\r\n    // Remove an edge, checking first to see if vertices are valid\r\n    removeEdge(vertex1, vertex2) {\r\n        if (vertex1 > this.size - 1 || vertex2 > this.size - 1) {\r\n            console.log('invalid vertex');\r\n        } else {\r\n            this.matrix[vertex1][vertex2] = 0;\r\n            this.matrix[vertex2][vertex1] = 0;\r\n        } \r\n    }\r\n\r\n    // Add a vertex, update size and adj matrix\r\n    addVertex() {\r\n        this.size++;\r\n        this.matrix.push([]);\r\n        for (let i = 0; i < this.size; i++) {\r\n            this.matrix[i][this.size - 1] = 0;\r\n            this.matrix[this.size - 1][i] = 0;\r\n        }\r\n    }\r\n\r\n    // Print values of the matrix\r\n    printMatrix() {\r\n        for (let i = 0; i < this.size; i++) {\r\n            let row = '';\r\n            for (let j = 0; j < this.size; j++) {\r\n                row += ` ${this.matrix[i][j]}`;\r\n            }\r\n            console.log(row);\r\n        }\r\n    }\r\n\r\n    // Utility function to find the vertex with minium cost from vertices not in MST\r\n    minKey(keys, mstSet) {\r\n        let min = Number.MAX_VALUE;\r\n        let minIndex = -1;\r\n\r\n        for (let i = 0; i < this.size; i++) {\r\n            if (mstSet[i] === false && keys[i] < min) {\r\n                min = keys[i];\r\n                minIndex = i;\r\n            }\r\n        }\r\n\r\n        return minIndex;\r\n    }\r\n\r\n    // Function to find MST using Prim's Algorithm\r\n    primMST() {\r\n        if(this.size <= 1) {\r\n            return [];\r\n        }\r\n\r\n        let parents = [];\r\n        let keys = [];\r\n        let mstSet = [];\r\n\r\n        // Initialize all arrays\r\n        for(let i = 0; i < this.size; i++){\r\n            parents.push(0);\r\n            keys.push(Number.MAX_VALUE);\r\n            mstSet.push(false);\r\n        }\r\n\r\n        // Set root of MST\r\n        keys[0] = 0;\r\n        parents[0] = -1;\r\n\r\n        for(let i = 0; i < this.size - 1; i++) {\r\n            let u = this.minKey(keys, mstSet);\r\n            mstSet[u] = true;\r\n\r\n            for(let v = 0; v < this.size; v++) {\r\n                if (this.matrix[u][v] !== 0 && mstSet[v] === false && this.matrix[u][v] < keys[v]) {\r\n                    parents[v] = u;\r\n                    keys[v] = this.matrix[u][v];\r\n                }   \r\n            }\r\n        }\r\n\r\n        parents.forEach((dst, src) => {\r\n            if(dst !== -1){\r\n                this.mst[src][dst] = 1;\r\n                this.mst[dst][src] = 1;\r\n            }\r\n        });\r\n\r\n        this.matrix.forEach((row, idx1) => {\r\n            row.forEach((cost, idx2) => {\r\n                // If this is not in our MST\r\n                if(cost !== 0){\r\n                    // Assign it 1 if it is in MST\r\n                    if(this.mst[idx1][idx2] === 1) {\r\n                        this.addEdge(idx1, idx2, 1);\r\n                    } else {\r\n                        // Assign it a random cost\r\n                        this.addEdge(idx1, idx2, Math.random());\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n}\r\n\r\nexport default Graph;","import Graph from \"./adj-matrix.graph\";\r\n\r\nclass Map {\r\n    constructor(size = 0) {\r\n        this.size = size;\r\n        this.rooms = [];\r\n        this.paths = new Graph(size);\r\n        this.focusedRoom = -1;\r\n        // Have ways to construct all 5 path types, and return the one we want in a graph representation\r\n        /* Could do \r\n            Make all paths\r\n            Find longest path\r\n            Normalize costs based on longest path\r\n            Find MST\r\n            Linear = graph of MST\r\n            For Sparse:\r\n                For all paths not in MST\r\n                    If random < 0.25\r\n                        Add path to graph\r\n            Similarly for Normal, and Dense\r\n            Complete will return the original \r\n        */\r\n    }\r\n\r\n    // AABB collision detection with optional padding\r\n    checkCollision(a, b, padding=0) {\r\n        if (a.x - padding < b.x + b.width && \r\n            a.x + a.width + padding  > b.x && \r\n            a.y - padding < b.y + b.height && \r\n            a.y + a.height + padding > b.y) {\r\n                return true;\r\n            } \r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    static getMidPoint(room) {\r\n        return ([room.x+room.width/2, room.y+room.height/2]);\r\n    }\r\n\r\n    distance(a, b) {\r\n        return Math.sqrt(((a[0] - b[0]) * (a[0] - b[0])) + ((a[1] - b[1]) * (a[1] - b[1])));\r\n    }\r\n\r\n    generateRooms(minSize, maxSize, gridWidth, gridHeight) {\r\n        const generatedRooms = [];\r\n        // Creates a set of random rooms we will try to place\r\n        const roomsToPlace = [];\r\n        for(var i = 0; i < this.size; i++){\r\n            let diff = maxSize - minSize;\r\n            let roomWidth = (Math.floor(Math.random() * diff) + minSize);\r\n            let roomHeight = (Math.floor(Math.random() * diff) + minSize);\r\n\r\n            roomsToPlace.push({\r\n                width: roomWidth,\r\n                height: roomHeight\r\n            });\r\n        }\r\n\r\n        let maxTries = 10;\r\n        let roomNum = 0;\r\n        roomsToPlace.forEach((r) => {\r\n            let placed = false;\r\n            let tries = 0;\r\n            while(!placed && tries < maxTries) {\r\n\r\n\r\n                // Try to place a room at a random spot\r\n                let valid = true;\r\n                let xPos = Math.floor(Math.random() * gridWidth);\r\n                let yPos = Math.floor(Math.random() * gridHeight);\r\n\r\n                // See if room is in bounds\r\n                if(xPos + r.width < gridWidth && yPos + r.height < gridHeight) {\r\n                    let newRoom = {\r\n                        x: xPos,\r\n                        y: yPos,\r\n                        width: r.width,\r\n                        height: r.height\r\n                    };\r\n\r\n                    let collidedRoom = generatedRooms.find((room) => {\r\n                        return this.checkCollision(newRoom, room, 1);\r\n                    });\r\n\r\n                    if(collidedRoom != null) {\r\n                        valid = false;\r\n                    }\r\n                }\r\n                else {\r\n                    valid = false;\r\n                }\r\n\r\n                if(valid){\r\n                    generatedRooms.push({\r\n                        id: roomNum,\r\n                        x: xPos,\r\n                        y: yPos,\r\n                        width: r.width,\r\n                        height: r.height,\r\n                        focused: false\r\n                    });\r\n                    placed = true;\r\n                    roomNum ++;\r\n                }\r\n                else {\r\n                    tries++;\r\n                }\r\n            }\r\n        });\r\n        this.rooms = generatedRooms;\r\n        this.size = roomNum;\r\n    }\r\n\r\n\r\n    generatePaths(connectivity) {\r\n        let generatedPaths = new Graph(this.size);\r\n        let maxCost = Number.MIN_VALUE;\r\n        this.rooms.forEach((r1, idx1, ar) => {\r\n            ar.forEach((r2, idx2) => {\r\n                let cost = Math.floor( this.distance(Map.getMidPoint(r1), Map.getMidPoint(r2)) * 100 );\r\n                if(cost > maxCost) {\r\n                    maxCost = cost;\r\n                }\r\n                generatedPaths.addEdge(idx1, idx2, cost);\r\n            });\r\n        });\r\n\r\n        // Initialize MST\r\n        generatedPaths.primMST();\r\n\r\n        // TODO: Fine tune these values\r\n        if(connectivity === 'sparse') {\r\n            generatedPaths.matrix.forEach((row, idx1) => {\r\n                row.forEach((cost, idx2) => {\r\n                    if(cost < 0.9) {\r\n                        generatedPaths.removeEdge(idx1, idx2);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        else if(connectivity === 'normal') {\r\n            generatedPaths.matrix.forEach((row, idx1) => {\r\n                row.forEach((cost, idx2) => {\r\n                    if(cost < 0.8) {\r\n                        generatedPaths.removeEdge(idx1, idx2);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        else if(connectivity === 'dense') {\r\n            generatedPaths.matrix.forEach((row, idx1) => {\r\n                row.forEach((cost, idx2) => {\r\n                    if(cost < 0.7) {\r\n                        generatedPaths.removeEdge(idx1, idx2);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        else if(connectivity === 'complete') {\r\n            // No work to be done\r\n        }\r\n        else {\r\n            // Default to linear\r\n            generatedPaths.matrix.forEach((row, idx1) => {\r\n                row.forEach((cost, idx2) => {\r\n                    if(cost < 1) {\r\n                        generatedPaths.removeEdge(idx1, idx2);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        this.paths = generatedPaths;\r\n    }\r\n\r\n    unsetFocusedRoom() {\r\n        if(this.focusedRoom !== -1) {\r\n            this.rooms[this.focusedRoom].focused = false;\r\n            this.focusedRoom = -1;\r\n        }\r\n    }\r\n\r\n    setFocusedRoom(id) {\r\n        this.unsetFocusedRoom();\r\n        this.focusedRoom = id;\r\n        this.rooms[id].focused = true;\r\n    }\r\n}\r\n\r\nexport default Map;","import React from 'react'\r\nimport Two from 'two.js'\r\nimport RoomData from './RoomData'\r\nimport Canvas from './Canvas'\r\nimport Header from './Header'\r\nimport Form from './Form'\r\nimport Graph from '../utils/adj-matrix.graph'\r\nimport Map from '../utils/map'\r\n\r\nfunction App() {\r\n    const [gridSize, setGridSize] = React.useState(25);\r\n    const [gridWidth, setGridWidth] = React.useState(20);\r\n    const [gridHeight, setGridHeight] = React.useState(20);\r\n    const [map, setMap] = React.useState(new Map());\r\n    const [selectedRoom, setSelectedRoom] = React.useState(-1);\r\n\r\n    var w = 600;\r\n    var h = 600;\r\n\r\n    function updateMap(numRooms, minSize, maxSize, mapWidth, mapHeight, connectivity) {\r\n        let m = new Map(numRooms);\r\n        m.generateRooms(minSize, maxSize, mapWidth, mapHeight);\r\n        m.generatePaths(connectivity);\r\n        setMap(m);\r\n        setSelectedRoom(-1);\r\n    }\r\n\r\n    // Define a draw function\r\n    // https://two.js.org/#basic-usage\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    function draw(ctx) {\r\n        w = gridSize * gridWidth;\r\n        h = gridSize * gridHeight;\r\n\r\n        var two = new Two({\r\n            type: Two.Types.canvas,\r\n            width: w,\r\n            height: h,\r\n            domElement: ctx.canvas\r\n        });\r\n\r\n        for(let i = 0; i < w; i+=gridSize) {\r\n            let line = two.makeLine(i, 0, i, h);\r\n            line.stroke = 'DarkGray';\r\n        }\r\n\r\n        for(let j = 0; j < h; j+=gridSize) {\r\n            let line = two.makeLine(0, j, w, j);\r\n            line.stroke = 'DarkGray';\r\n        }\r\n\r\n         // Draw all rooms\r\n        map.rooms.forEach((r) => {\r\n            // Takes center of rect as it's x/y\r\n            var txt = two.makeText(r.id, r.x * gridSize + gridSize/2, r.y * gridSize + gridSize/2);\r\n            txt.size = gridSize;\r\n            txt.stroke = 'black';\r\n            txt.opacity = 0.75;\r\n            var rect = two.makeRectangle(r.x * gridSize + (r.width * gridSize / 2), r.y * gridSize + (r.height * gridSize/2), r.width * gridSize, r.height * gridSize);\r\n            rect.fill = (r.focused ? 'blue' : 'orangered');\r\n            rect.opacity = 0.5;\r\n        });\r\n\r\n        // Show all generated connections\r\n        // Blue for any connections not int MST\r\n        map.paths.matrix.forEach((row, idx1) => {\r\n            row.forEach((cost, idx2) => {\r\n                if(cost !== 0){\r\n                    let room1 = Map.getMidPoint(map.rooms[idx1]);\r\n                    let room2 = Map.getMidPoint(map.rooms[idx2]);\r\n                    let line = two.makeLine(room1[0] * gridSize, room1[1] * gridSize, room2[0] * gridSize, room2[1] * gridSize);\r\n                    line.stroke = (cost === 1 ? 'Black' : 'Blue');\r\n                    line.lineWidth = 10;\r\n                }\r\n            });\r\n        });\r\n\r\n        two.update();\r\n    }\r\n\r\n    // Checked to see if user clicked on a specific room, and will highlight that room\r\n    function handleClick(event){\r\n        let mouseX = event.nativeEvent.layerX;\r\n        let mouseY = event.nativeEvent.layerY;\r\n        \r\n        let roomClicked = map.rooms.findIndex((r) => {\r\n            return (mouseX > r.x * gridSize && mouseX < r.x * gridSize + r.width * gridSize && mouseY > r.y * gridSize && mouseY < r.y * gridSize + r.height * gridSize);\r\n        });\r\n\r\n        if(roomClicked === -1) {\r\n            map.unsetFocusedRoom();\r\n            setSelectedRoom(-1);\r\n        }\r\n        else {\r\n            map.setFocusedRoom(roomClicked);\r\n            setSelectedRoom(roomClicked);\r\n        }\r\n    }\r\n\r\n    // temporary function for printing room parameters\r\n    function getRoomParams() {\r\n        let r = map.rooms[selectedRoom];\r\n        return 'id: ' + r.id + '\\n ' +\r\n        'x: ' + r.x + '\\n ' +\r\n        'y: ' + r.y + '\\n ' +\r\n        'height: ' + r.height + '\\n ' +\r\n        'width: ' + r.width + '\\n ';\r\n    }\r\n\r\n    return <div>\r\n        <Header />\r\n        <div className='row'>\r\n            <div className='col'>\r\n                <Form onGenerate={updateMap}\r\n                    changeWidth={setGridWidth}\r\n                    changeHeight={setGridHeight}\r\n                />\r\n            </div>\r\n            <div className='col'>\r\n                <Canvas \r\n                    draw={draw} \r\n                    options={{\r\n                        context: '2d'\r\n                        }}\r\n                    style={{\r\n                        borderStyle: 'solid'\r\n                    }}\r\n                    width={w}\r\n                    height={h}\r\n                    onClick={handleClick}\r\n                />\r\n            {selectedRoom !== -1 ? <RoomData data={getRoomParams()} /> : null}\r\n            </div>\r\n        </div>\r\n  </div>;\r\n}\r\n\r\nexport default App\r\n\r\n// <p>{focusedRoom ? getRoomParams(focusedRoom) : null}</p>{/*TODO: Make this an actual component that renders underneath canvas*/}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport './styles/styles.css';\n\nReactDOM.render(<App />, \n  document.getElementById('root')\n);\n\n// https://dev.to/yuribenjamin/how-to-deploy-react-app-in-github-pages-2a1f\n// For changes, commit and push to remote master, then run \"npm run deploy\" again\n"],"sourceRoot":""}